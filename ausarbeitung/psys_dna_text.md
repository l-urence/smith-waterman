# Einleitung
Seit einigen Jahren steigt die Taktfrequenz von Prozessoren (CPU) nicht weiter an, dies ist durch die hohe Wärmeabgabe bei hohen Taktfrequenzen des Prozessors bedingt. Die Entwicklung vom Mehrkernprozessoren erlaubt es durch Parallelisierung dies teilweise zu kompensieren. Mittlerweile ist nicht nur die Parallelisierung auf herkömmlichen CPUs von Bedeutung. Die rasante Entwicklung von Grafikarten-Prozessoren (GPU) macht diese für parallele Ausführung von Programmen immer interessanter. Verantwortlich ist die wesentlich höhere Anzahl an Prozessorkernen einer GPU im vergleich zu einer herkömmlichen CPU. Auch die die schneller ansteigende Leistung der GPUs im Bezug zu CPUs lassen der Grafikkarte für Parallelisierung mehr Bedeutung zukommen. \cite{cpu:limit}

Diese Arbeit befasst sich mit der Parallelisierung eines Algorithmus für Sequenz Aligments in zwei Zeichenketten. Anwendung finden Algorithmen zur Bestimmung von Aligments zum Großteil in der Bioinformatik, um beispielsweise DNA-Sequenzen zu analysieren. Diese Arbeit betrachtet den Smith-Waterman Algorithmus, welcher das optimale lokale Alignment zweier Zeichenketten A und B ermittelt. Das verwendete Framework für die Parallelisierung auf der GPU ist OpenCL. Die Open Computing Language (OpenCL) definiert einen plattformübergreifenden Standart zum Ausführen von parallelen Anwendungen auf Mehrkern CPUs und GPUs \cite{cl:apple}. Ziel dieser Arbeite ist es die Nebenläufigkeit des Smith-Waterman Algorithmus zu identifizieren und diesen mittels OpenCL auf der GPU zu parallelisieren. Vergleiche zwischen der seriellen und parallelen Version des Algorithmus geben Aufschluss darüber, ob eine effektive Parallelisierung des Algorithmus auf der GPU, unter Berücksichtigung der Implementierung, möglich ist.

# Smith-Waterman Algorithmus
Der Smith-Waterman Algorithmus ist konstruiert um das optimale lokale Alignment zweier Zeichenketten oder Sequenzen zu bestimmen, somit ermittelt er den ähnlichsten Abschnitt in einer Zeichenkette. T.F.  Smith und M.S. Waterman veröffentlichten den Algorithmus 1981 in dem Paper: *Identification of common molecular subsequences*. Wie der zuvor entworfene Algorithmus von Needleman & Wunsch (1970) wird mit Hilfe einer Matrix das Alignment berechnet. Es gibt eine viel Zahl von heuristischen Algorithmen, welche vor der Entwicklung des Smith-Waterman Algorithmus verfasst worden, jedoch waren diese für biologische Untersuchungen nicht hinreichend genug oder nicht interpretierbar. 1982 verbesserte Gotoh den Algorithmus vom Smith & Waterman. Der Ursprüngliche Algorithmus benötigte $M^2N$ Schritte um das lokale Alignment zu erhalten, Gotoh reduzierte die benötigten Schritte auf $MN$, wobei $M$ und $N$ ($M\ge N$) die Längen der zu vergleichenden Zeichenketten bzw. Sequenzen sind. \cite{sw:paper, sw:gotoh}

Bevor jedoch der Algorithmus vom Smith & Waterman beschrieben wird, soll der Unterschied zwischen lokalen und globalen Aligments geklärt werden. Lokale bzw. globale Alignments betrachten die zu untersuchenden Sequenzen unterschiedlich und ermitteln somit verschiedene Ergebnisse. Ein globales Alignment betrachtet das Alignment auf der gesamten Länge der Sequenzen (vgl. Listing \ref{alignment}). Hingen betrachtet das lokale Alignment nur ähnliche Abschnitte in einer Sequenz (vgl. Listing \ref{alignment}). Nun ist es möglich, dass mehrere lokale Alignments in einer Sequenz vorkommen, um das optimale lokale Alignment zu bestimmen, wählt ein Algorithmus das Alignment mir der höchsten Wertigkeit aus. Der Needleman & Wunsch Algorithmus ermittelt ein globales Alignment, indessen der Smith-Waterman Algorithmus ein optimales lokales Alignment bestimmt. \cite{sw:alignment}

\lstinputlisting[label=alignment, caption={Beispiel für globales und lokales Alignment}]{./src_examples/alignemt.txt}

## Algorithmus
Der Smith-Waterman Algorithmus basiert auf dem Paradigma der dynamischen Programmierung. Hierbei ist "Programmierung" nicht im Sinne von schreiben von Code zu verstehen, dynamische Programmierung löst das Probleme durch das Ausfüllen einer Tabelle (Matrix). Wie auch bei bei der Methode von "teile und herrsche" zerlegt dynamische Programmierung ein Probleme in viele leichter zu lösende Teilprobleme, deren Ergebnisse in einer Tabelle hinterlegt werden. Jedoch sind die Teilprobleme untereinander von einander Abhängig, da ihre Berechnungen bzw. Lösungen auf denen der Vorgänger beruhen. Generell lässt sich dynamische Programmierung auf Optimierungsprobleme anwenden. Solche Probleme bestehen aus einer Vielzahl von korrekten Lösungen, wohingegen nur eine optimale Lösung des Problems (Minima, Maxima) von Interesse ist. \cite{sw:dynamic_prog}
Gegeben sind zwei Zeichenketten bzw. Sequenzen ${A=a_1a_2\dots a_n \text{ und } B=b_1b_2\dots b_m}$. Die Ähnlichkeit zweier Elemente einer Zeichenkette (Buchstaben) sind durch die Funktion $s(a,b)$ definiert. Das entfernen von Elementen aus der Zeichenkette ist duck das Gewicht $W_k$ bestimmt. Für das ermitteln von gleichartigen Segmenten in den Zeichenketten wird eine Matrix $H$ mit den folgenden Werten initialisiert: $H_{k0} = H_{0l} = 0 \text{ für } 0\le k\le n\land 0\le l\le m$, wobei $m$, $n$ die länge der Zeichenketten $|A|$ und $|B|$ sind. Die Werte in $H$ ergeben sich aus den Operationen (siehe Formel \ref{eq:sw}) an der Stelle $H_{ij}$  mit den Elementen $a_i \text{ und } b_j$, hierbei ist $1\le i\le n\land 1\le j\le m$ zu beachten. Ist das Ergebnis einer Operation *negativ* ist es *Null* zu setzten. Um in der Zeichenkette das Segment zu finden, dass die größte Ähnlichkeit aufweist muss das Element in $H$ gefunden werden, welches den größten Wert hat. Von diesem Element ausgehend könnenden die die nachfolgenden Elemente in einem Rückverfolgungsprozess^[Der Weg aus dem sich das Element im Vergleich mit den Operationen aus Formel \ref{eq:sw} ergeben hat.] (Traceback) bestimmt werden. Der Traceback endet sobald ein Matrix Element *Null* ist. Dieser Prozess führ zu dem ähnlichsten Segmenten und zu dem optimalen Alignment der Zeichenketten $A$ und $B$.\cite{sw:paper}
\input{./eq/sw}

## Beispiel
\label{sec:bsp}
Im Folgenden soll ein Beispiel gegeben werden, welches den Algorithmus verdeutlichen soll. Anhand der Zeichenketten $A=\text{ANANAS und } B=\text{BANANE}$, wobei die Parameter für den Vergleich wie wie folgt gewählt sind: \input{./eq/param}
Die Abbildungen Fig. \ref{fig:matrix:init} und \ref{fig:matrix:comp} zeigen die Initialisierung der Matrix $M$ sowie die Berechnung der jeweiligen Elemente von $M$ durch die vorher festgelegten Operationen aus der Formel \ref{eq:sw}. Die Pfeile in der Abbildung Fig. \ref{fig:matrix:comp} zeigen auf das Element aus dem sich das Element an der Stelle $H_{ij}$ ergibt.

\input{./img/matrix_1}
\input{./img/matrix_2}

Ist die Matrix wie in der Abbildung Fig. \ref{fig:matrix:comp} ausgefüllt, kann mittels des Tracebacks, ausgehend von dem Element mit dem höchsten Wert, die ähnlichste Sequenz aus der Zeichenkette $A\text{ und } B$ bestimmt werden (siehe Fig. \ref{fig:matrix:trace}). Aus dem Traceback ergibt sich somit ein Alignment für $A$ und $B$ von *ANAN*.

## Serieller Ansatz
Die Implementierung des seriellen Ansatzes hat im Kern zwei Matrizen. Die erste Matrix $H$ enthält die Werte, die aus den Ergebnissen der Operationen und kann sich wie die Matrix aus aus dem Beispiel \ref{sec:bsp} vorgestellt werden. Die zweite Matrix $M$ ist für das Traceback notwendig. Sie dient für die Speicherung aus welchem Element sich das Element $H{ij}$ zusammensetzt. Der Pseudocode \ref{seriel} soll die Implementation der seriellen Version des Smith-Waterman Algorithmus verdeutlichen. Die beiden ersten Zeilen initialisieren die Matrix für die Berechnungen des Alignments und die Matrix für das Merken aus welchem Element sich das aktuelle Element ergibt. Das ausfüllen der Matrix mittels der Operationen aus Formel \ref{eq:sw} findet in den Zeilen 3-8 statt. Zeile 6 wendet die Operationen auf das aktuelle Element $H_{ij}$ an. In der darauffolgenden Zeile findet das Speichern der benutzen Operation statt, aus welcher sich der gegangene Pfad im Traceback rekonstruieren lässt. Die in den Zeilen 9-11 definierten Variablen dienen für den Traceback. *$\text{Result}_a$* und *$\text{Result}_b$* halten die im Traceback ermittelten Sequenzen in den Zeichenketten $A$ und $B$. *Current* speichert den aktuellen Wert, $Next$ den Folgewert, welche mittels $M$ bestimmt werden kann. In den Zeilen 12-25 wird das optimale lokale Alignment mittels $H$ und $M$ ermittelt und die ähnlichsten Segmente zurückgegeben.

\input{./src_examples/serial.tex}

## Paralleler Ansatz mittels OpenCL
\label{sec:parallel}
Für eine parallele Implementierung des Smith-Waterman Algorithmus ist das Erkennen der Abhängigkeiten der Operatoren, welche in der Formel \ref{eq:sw} definiert sind, notwendig. Aus den Indizes der benutzen Operatoren ($i-1,j-1$, $i-1,j$ und $i,j-1$) um auf Elemente aus $H$ zuzugreifen geht hervor, dass die Operationen von Vorgängerwerten in der Matrix abhängen. Dies macht es nicht möglich $H$ Zeile für Zeile parallel auszufüllen. Eine andere Herangehensweise ist es die Matrix in Antidiagonalen^[Die Addition von $i$ und $j$ gibt pro Antidiagonale immer den selben Wert.] zu berechnen (siehe Fig. \ref{fig:anti}). Die Herausforderung hier bei ist, dass die Längen der Antidiagonalen  in Abhängigkeit von $n$ und $m$ ändern. Somit müssen die Antidiagonalen dem entsprechend berechnet werden. Ein weiteres Problem bei diesem Ansatz ist, dass es zu einem ohne Overhead bei der parallelen Ausführung kommet, da die jeweiligen Antidiagonalen mit den Elementen von denen Sie Abhängen auf die entsprechenden Prozessoren verteilt werden müssen. Eine bessere Vorgehensweise ist es die Matrix $H$ in mehrere Blöcke zu unterteilen (siehe Fig. \ref{fig:sub}). Jeder Block ist nur von seinem Vorgänger abhängig. Die schwarzen und roten Rahmen in der Abbildung Fig. \ref{fig:sub} zeigen den gesamten Block der für eine Berechnung betrachtet wird. Die grün und blau ausgefüllten Blöcke sind die Werte die in einem Block berechnet werden. In der Abbildung Fig. \ref{fig:sub} ist zu erkennen, dass sobald der erste grüne Block berechnet ist, lassen sich die beiden nachfolgenden blauen Blöcke voneinander unabhängig berechnen. Zu Beachten ist, dass für jede Berechnung eines Blockes die erste horizontale und vertikale Zeile der vorigen Berechnung mitgeführt werden muss. Dies führt aber zu einem geringeren Overhead als die Herangehensweise mit Antidiagonalen. \cite{sw:parallel}

\input{./img/matrix_3}

### OpenCL^[Dieser Abschnitt soll lediglich einen Einblick in die Funktionsweise OpenCLs geben, jedoch keine Einführung in die Programmierung mittels OpenCL, da es eine Vielzahl davon im Internet zu finden ist.]
Die Open Computing Language ist ein Plattform übergreifender Standart, welcher für das Entwickeln von Anwendungen auf hoch parallelen Prozessoren entworfen ist. Basierend auf der C99 Programmiersprache können Kernel auf der CPU oder GPU ausgeführt werden. Die OpenCL Spezifikation bezeichnet Geräte auf denen das Programm ausgeführt wird im allgemeinen als *Device*. Jedes *Device* besteht aus einer Reihe von *Compute Units*. Die *Compute Unit* besteht aus mehreren Prozessorelementen und einem Lokalen Speicher. Eine *Workgroup* wird auf einer *Compute Unit* ausgeführt, die *Compute Units*, welche den Prozessorkernen entsprechen limitieren die gleichzeitige Ausführung. Das dabei auf der GPU oder CPU ausgeführte Programm, heißt *Kernel*. Der *Kernel* ist eine Funktion, die in der OpenCL Sprache verfasst ist und zur Laufzeit für das entsprechende *Device* kompiliert wird. Während der gleichzeitigen Ausführung rechnen eine Vielzahl von "Kernel Instanzen" auf verschiedenen Bereichen der zu bearbeitenden Daten. Der *Host*, das Programm, welches den *Kernel* aufruft, alloziert Speicher für die benötigten Argumente der *Kernel* Funktion und übergibt sie dieser beim Aufruf. Nach der Abarbeitung der Daten, können diese wieder ausgelesen werden und der vorher allozierte Speicher freigegeben. \cite{cl:apple}

### SimpleOpenCL
Aus dem OpenCL Beispiel des Apple Developer Guide \cite{cl:example} geht hervor, dass die Programmierung mittels OpenCL einen Großteil von Boilerplate Code erzeugt. Dieser ist für die Initialisierung von OpenCL, das Allozieren und Kopieren von Speicher auf die *Devices* notwendig. Sowie das Ausführen des *Kernel*, das Abrufen von Ergebnissen und das Freigen und Beenden von OpenCL. Er macht den Quellcode unübersichtlich, den Umgang mit OpenCL aufwändig und schwer wartbar. SimpleOpenCL implementiert OpenCL, bietet jedoch über eine C Bibliothek eine sehr vereinfachte Schnittstelle zu OpenCL. Ausgerichtet für die Bedürfnisse wissenschaftlicher Untersuchungen und die Entwicklung von Prototypen, ermöglicht SimpleOpenCl einen einfacheren Umgang mit OpenCL und erleichtre die Entwicklung erheblich. Durch SimpleOpenCL lässt sich der "Host Code" um den Kernel auszuführen stark reduzieren, dabei bleibt der "Kernel Code" exakt der gleiche wie bei einer regulären OpenCL implementation. \cite{cl:simple}

### Implementation
Anstatt nativen OpenCL "Host Code" zu schreiben verwendet die Implementation für den Host SimpleOpenCL. Wie auch die serielle Implementation des Smith-Waterman Algorithmus basiert auch die parallele Ausführung auf den Matrizen $H$ und $M$. Wie in \ref{sec:parallel} vorgeschlagen werden Teilblöcke (i.f. Submatritzen) entlang einer Antidiagonalen von $H$ parallel berechnet. Für die Berechnung der Antidiagonalen kommt der aus \cite{cl:diagonal} vorgeschlagene Algorithmus zum tragen. Der Algorithmus ist so angepasst, dass er die Startindizes der Submatritzen ermittelt. Mit der festgelegter Dimension $d$ für jede Submatrix sind die Elemente der jeder Submatrix gegeben. Listing \ref{diagonal} weist den Algorithmus für die Berechnung der Submatritzen aus einem Quellcodeabschnitt auf. *sub* entspricht hierbei $d$ für jede Submatrix und *n* der Länge der Zeichenketten. Zur vereinfachten Berechnung wird vorausgesetzt, dass die Längen der Zeichenketten $A$ und $B$ gleichlang sind, also $m = n$. Des Weiteren muss $d$ so gewählt sein, dass es $m$ bzw. $n$ ohne Rest teilt ($m \bmod d = 0 \land n \bmod d = 0$), ansonsten ist es nicht möglich $H$ in gleiche Submatritzen zu zerteilen. Der Pseudocode \ref{parallel} zeigt den Ablauf in vereinfachter Form für parallele Ausführung. Die Operatoren aus Formel \ref{eq:sw} können parallel in *computeSubmatrixsInParallel* auf die SUbmatritzen angewandt werden. Lediglich der Traceback um auf die ähnlichen  Teilsegmente und das Alignment der Zeichenketten $A$ und $B$ zukommen ist wieder seriell.

\lstinputlisting[label=diagonal, caption={Berechnung der Startindizes für Submatritzen.}]{./src_examples/diagonal.c}

\input{./src_examples/parallel.tex}

# DNA
Die DNA (Desoxyribonukleinsäure) ist ein Biomolekül und ist Bestandteil jedes Lebewesen und Viren. Es besteht aus vielen Bestandteilen, den sogenannten Nukleotiden. Jedes Nukleotid besteht aus Phosphorsäure bzw. Phosphat und Zucker (Desoxyribose) sowie einer einer Base. Bei der Base kann es sich um Adenin (A), Thymin (T), Cytosin (C) oder Guanin (G) handeln. Die Phosphorsäure und der Zucker sind immer gleich und bilden den Strang des DNA Moleküls. Dabei bilden immer zwei Nukleotide anhand ihrer Basen ein Basenpaar. Es können jedoch nur Basenpaare aus Adenin und Thymin oder Cytosin und Guanin gebildet werden (siehe Abbildung \ref{fig:dna1}). Anhand der Komplexität der DNA Sequenz, die beim Menschen aus 3.101.788.170 Basenpaaren besteht, erfolgt die DNA Sequenzierung abschnittsweise. \cite{dna:dna}

![Strukturmodell eines DNA-Moleküls \cite{dna:dna1} \label{fig:dna1}](./img/dna1)

## Aligments in der DNA
Der Vergleich (Alignment) von DNA Sequenzen spielt eine wichtige Rolle in der Forschung, Medizin, Forensik und Bioinformatik. Es ist mit Hilfe von Algorithmen, wie dem Smith-Waterman Algorithmus möglich zwei DNA Sequenzen miteinander zu vergleichen. Stellt man eine biologische Sequenz als einen eindimensionalen Zeichenkette dar, so kann der Vergleich der beiden Sequenzen als zeichenweiser Vergleich von diesen Zeichenketten verstanden werden. Dazu werden als Zeichen die Abkürzungen der Basenpaare (AT, TA, CG, GC) verwendet. Ein sehr kurzes Beispiel einer Sequenz könnte, wie folgt sein: "CGCGATCGATCGTACG". Ziel ist es den Grad  Ähnlichkeit bzw. Unähnlichkeit zu bestimmen.

In der Forensik können DNA Sequenzen mit einer vorgegebenen Sequenz verglichen werden, um Täter zu identifizieren. In der Forschung können z.B. Spezies mit anderen Spezies oder defekte DNA Sequenzen mit korrekten DNA Sequenzen verglichen werden. \cite{dna:dna}

# Ergebnisse
Für das ermitteln der Performance, der seriellen bzw. parallelen Ausführung des Smith-Waterman Algorithmus wurden zufällige Zeichenketten bestehen aus den Buchstabenpaaren ""AT", "TA", "CG", "GC" mit fester Länge generiert und untereinander verglichen.

# Zusammenfassung

# Ausblick